#notes for design patterns

*Design patterns
-Is a general repeatable solutions to some commonly occuring problems during software design process.
-It's not a finished design that can be employed to development process
-It's rather a template or description that can continously be used to solve problems associated with      designs and it can be used in many different situations.


*USES OF DESIGN PATTERNS
-It can speed up the development process by employing the tested,proven development paradigms
-It can help in effective development by considering issues that may not arrise earlier until later on in implementations.
-It improves readability to the coders and archtects that are familiar with the patterns
-It provides general solutions to the problems associated with designs rather than having one issue at a time
-patterns allows developers to communicate using well-known and well understood names for software interaction 
-They can be improved over time making them more robust than ad-hoc designs


*CREATIONAL DESIGN PATTERNS
-These design patterns uses class instantations.
-They are of two types
*class-creation patterns
-it uses class inheritance effectively in instantation process
*object-creational patterns
-it uses delegation effectively to get job done

>Abstract Factory
-it creates an instance of several families of classes

>builder
-it separates object construction from it's presentation 

>Factory method
-creates an instance of several derived classes

>Object Pool
-Avoid expensive acquistions and release of resources by recycling objects that are not in use.

>Prototype
-A fully initialized instance to be copied or cloned

>singleton
-Is a class of which only a single instance can exist

*STRUCTURAL DESING PATTERNS
-This pattern is all about class and object composition.Structural class-creation uses class inheritance to compose interfaces while structural object-creation patterns defines new ways to compose objects to obtain new functionalities.

>adapter
-Matches instances of different classes

>Bridge
-It separates object interfaces from its implementation

>Composite
-Is a tree structure of simple composite objects

>Decorator
-Adds responsibilities to the object dynamically

>Facade
-A single class that represents a whole subsystems 

>Flyweight
-A fine grained instance used for efficient sharing

>Private class/Data
-prevents/Restricts accessor/mutator

>Proxy
-An object represents another object


*BEHAVIORAL DESIGN PATTERNS
-These designs patterns are all about class's objects communication 
-it deals with how objects communicates of a class

>chain of responsibilities
-Is a way of passing a request between a chain of objects

>command
-encapsulates a command request as an object

>Interpreter
-Is a way to include langauge element into a program

>Iterator
-sequentially access the elements of a list/collection

>Mediator
-defines simplified communication between a classes

>Memento
-captures and restore an object's internal state

>Null object
-Is design to act as a default value of an object

>Observer
-Is a way of notfying a change to a number of classes

>state
-it alters object's behavior when its state changes

>strategy
-encapsulates an algorithm inside a class

>Template method
-defer the exact algorithms of a class to a subclass

>Visitor
-defines a new operation of in a class without any changes


* REFACTORING
-it refers to process of improving the internal structure,design and quality of the code without changing it's external behavior.
-it improves the readability,maintainablity and perfomance while preserving it's functionalities.

* BAD CODE SMELLS
>Bloaters
-Are codes, methods and classes that have increased to such a large quantity which becomes now difficult to work with.
- They don't crop abruptly they rather take some time as the program evolves.

>Object-orientation Abusers
- They are smells that are incomplete or incorrect application of object-oriented programming principles.

> Change Preventers
- These smells mean that if you need to change code in one place then you have to change many other places as well. This makes the program development process becomes complicated and expensive as a result.

>Dispensables
- A dispensable is something pointless and unneeded whose absence would make the code cleaner,efficient and easier to understand.

>Couplers
- All the smells in this grp contribute to excessive coupling between classes.

* REFACTORING TECHNIQUES

> Composing methods
- In most cases the long methods are the roots of all evils.
- The vagaries of this codes inside these methods conceal execution and makes it difficult to understand and change.
- This refactoring techniques removes the code duplication which provides room for improvements.

> Moving features between objects
- This refactoring techniques shows how to safely move functionalities between classes,create new classes and how to hide implementation details from the public access.

> Organizing Data
- This techniques helps with data handling,replacing primitives with rich class functionalities and untangling of class associations which makes classes more portable and reusable

>Simplifying Conditional expressions
- conditionals gets more and more complicated in their logic and yet there are techniques to combat this example replace conditionals with polymorphism, introduce null objects

> Simplifying method calls
- This techniques makes the method calls easier to understand and in turn it simplifies the interfaces for interaction between classes.


*--------------------------------REFACTORING GURU ----------------------------------------------
- This is an online platform that contains materials concerning design patterns and refactoring that plays useful to developers who incoporates the knowledge to their projects for better performance,maintainability and scaling.

* CLEAN CODES
- The main intention of refactoring is to fight technical debt. It transforms a messy into clean code and simple designs.

* Features of clean code

i/ clean code does not contain bloaters,duplicated methods,poor variable naming
ii/ clean codes contains minimal number of classes and other moving parts
iii/ clean code passes all the tests
iv/ clean code is easier and cheaper to maintain

* Technical debt
- an act of continously developing a software without implementing tests, refactoring which in turn it slows down the development process.

* causes of technical debt
i/ Business pressure

ii/ Lack of understanding of the consequences of the technical debt

iii/ Failure to combat the cherence of components
- This is when the project resembles the monolith than the product of individual modules.
-In this case, changes to one module will affect the other modules.Team development is made more difficult because it's difficult to isolate the work individual members.

iv/ Lack of tests

v/ Lack of documentation
- This will slow down the process as new people will have to be introduce to the project. And it's a disaster if key people leave the project

vi/ Lack of interaction between team members

vii/ Long term simultenous development in different branches
- This happens when the changes are not merged regulary which leads to accumulation of technical debts.

viii/ Delayed refactoring
ix/ Lack of compliance
x/ Incompetence

* HOW TO REFACTOR
- Refactoring process should be done as a series of small changes.

>checklist of refactoring
-The code should be cleaner
-new function should not be created during refactoring
-All existing tests must pass after refactoring

* NOTE:
How to solve the problem of long method in bloaters is by using extract method
PROBLEM

def printOwing(self):
 self.printBanner()

 #print details
 print('name:',self.name)
 print('amount:',self.getoutstanding)

SOLUTION

def printOwing(self):
 self.printBanner()
 self.printDetails(self.getoutstanding())

def printDetails(self, getoutstanding):
 print("name:",self.name)
 print("amount:", getoutstanding)


* REPLACE TEMP WITH QUERY
def CalculateTotal():
 baseprice = quantity * itemprice
 if baseprice > 1000:
  return baseprice * 0.95
 else:
  return baseprice * 0.98


SOLUTION

def CalculateTotal():
 if baseprice() > 1000:
  return baseprice * 0.95
 else:
  return baseprice * 0.98

def baseprice():
 return   quantity * itemprice
   

METHODS FOR REFACTORING
- Extract method
- Replace temp with query
- Extract variable
- Inline method
- Inline temp
- Split temporary variable
- Substute algorithms